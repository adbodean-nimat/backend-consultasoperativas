"use strict";

var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorPickerVue2 = exports.ColorPicker = void 0; // @ts-ignore

var Vue = require("vue");

var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version[0] === '3';

var kendo_vue_buttons_1 = require("@progress/kendo-vue-buttons");

var kendo_vue_common_1 = require("@progress/kendo-vue-common");

var package_metadata_1 = require("../package-metadata");

var Picker_1 = require("./Picker");

var ColorPalette_1 = require("./ColorPalette");

var ColorGradient_1 = require("./ColorGradient");
/**
 * @hidden
 */


var DEFAULT_GRADIENT_SETTINGS = {
  opacity: true
};
/**
 * @hidden
 */

var DEFAULT_PALETTE_SETTINGS = {
  palette: ColorPalette_1.DEFAULT_PRESET,
  tileSize: ColorPalette_1.DEFAULT_TILE_SIZE
};
/**
 * @hidden
 */

var isControlled = function isControlled(prop) {
  return prop !== undefined;
};
/**
 * @hidden
 */


var ColorPickerVue2 = {
  name: 'KendoColorPicker',
  // @ts-ignore
  emits: {
    'open': null,
    'close': null,
    'activecolorclick': null,
    'focus': null,
    'blur': null,
    'change': null
  },
  props: {
    value: {
      type: String,
      default: undefined
    },
    defaultValue: String,
    disabled: Boolean,
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    paletteSettings: {
      type: Object,
      default: function _default() {
        return DEFAULT_PALETTE_SETTINGS;
      }
    },
    valid: {
      type: Boolean,
      default: true
    },
    tabIndex: {
      type: Number,
      default: 0
    },
    title: String,
    icon: String,
    iconClassName: String,
    popupSettings: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    gradientSettings: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    open: {
      type: Boolean,
      default: undefined
    },
    size: {
      type: String,
      default: 'medium',
      validator: function validator(value) {
        return [null, 'small', 'medium', 'large'].includes(value);
      }
    },
    rounded: {
      type: String,
      default: 'medium',
      validator: function validator(value) {
        return [null, 'small', 'medium', 'large', 'full'].includes(value);
      }
    },
    fillMode: {
      type: String,
      default: 'solid',
      validator: function validator(value) {
        return [null, 'solid', 'flat', 'outline'].includes(value);
      }
    },
    view: {
      type: String,
      default: 'palette',
      validator: function validator(value) {
        return ['gradient', 'palette', 'combo'].includes(value);
      }
    }
  },
  data: function data() {
    return {
      focused: false,
      currentValue: this.$props.defaultValue,
      currentOpen: false
    };
  },
  computed: {
    isValueControlled: function isValueControlled() {
      return this.$props.value !== undefined;
    },
    isOpenControlled: function isOpenControlled() {
      return this.$props.open !== undefined;
    },
    computedValue: function computedValue() {
      return this.isValueControlled ? this.$props.value : this.currentValue;
    },
    computedOpen: function computedOpen() {
      return this.isOpenControlled ? this.$props.open : this.currentOpen;
    },
    computedIconClassName: function computedIconClassName() {
      var icon = this.$props.icon;
      return this.$props.iconClassName || icon && "k-icon k-i-" + icon;
    },
    wrapperClassName: function wrapperClassName() {
      var _a;

      var _b = this.$props,
          size = _b.size,
          fillMode = _b.fillMode,
          rounded = _b.rounded;
      return _a = {
        'k-picker': true,
        'k-colorpicker': true,
        'k-icon-picker': true
      }, _a["k-picker-" + (kendo_vue_common_1.kendoThemeMaps.sizeMap[size] || size)] = size, _a["k-picker-" + fillMode] = fillMode, _a["k-rounded-" + (kendo_vue_common_1.kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a['k-invalid'] = !this.valid, _a['k-disabled'] = this.disabled, _a['k-focus'] = this.focused, _a;
    }
  },
  created: function created() {
    kendo_vue_common_1.validatePackage(package_metadata_1.packageMetadata);
    this.focusableElementGuid = kendo_vue_common_1.guid();
  },
  mounted: function mounted() {
    this.button = kendo_vue_common_1.getRef(this, 'button');
  },
  updated: function updated() {// this.button = getRef(this, 'button');
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var _this2 = this;

    var _a;

    var _this = this;

    var h = gh || createElement;
    var _b = this.$props,
        disabled = _b.disabled,
        tabIndex = _b.tabIndex,
        dir = _b.dir,
        view = _b.view;

    var renderGradiente = function renderGradiente() {
      return h(ColorGradient_1.ColorGradient, __assign({
        tabIndex: 0,
        attrs: this.v3 ? undefined : __assign({
          tabIndex: 0,
          value: this.computedValue || undefined
        }, this.gradientSettings),
        ref: kendo_vue_common_1.setRef(this, 'gradient'),
        value: this.computedValue || undefined,
        onChange: this.onGradientChangeHandler,
        on: this.v3 ? undefined : {
          'change': this.onGradientChangeHandler,
          'focus': this.onFocusHandler,
          'blur': this.onBlurHandler,
          'keydown': this.onKeyDownHandler
        },
        onFocus: this.onFocusHandler,
        onBlur: this.onBlurHandler,
        onKeydown: this.onKeyDownHandler
      }, this.gradientSettings));
    };

    var renderPalette = function renderPalette() {
      return h(ColorPalette_1.ColorPalette, __assign({
        onKeydown: this.onKeyDownHandler,
        on: this.v3 ? undefined : {
          'keydown': this.onKeyDownHandler,
          'change': this.onPaletteChangeHandler,
          'blur': this.onBlurHandler
        },
        ref: kendo_vue_common_1.setRef(this, 'palette'),
        value: this.computedValue || undefined,
        attrs: this.v3 ? undefined : __assign({
          value: this.computedValue || undefined
        }, this.paletteSettings),
        onChange: this.onPaletteChangeHandler,
        onBlur: this.onBlurHandler
      }, this.paletteSettings));
    }; // const dir = useDir(focusableElementGuid, props.dir);


    return h("span", {
      "class": this.wrapperClassName,
      dir: dir,
      attrs: this.v3 ? undefined : {
        dir: dir,
        id: this.$props.id,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        tabindex: kendo_vue_common_1.getTabIndex(tabIndex, disabled),
        title: this.$props.title
      },
      id: this.$props.id,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      ref: this.focusableElementGuid,
      tabindex: kendo_vue_common_1.getTabIndex(tabIndex, disabled),
      title: this.$props.title,
      onKeydown: this.onButtonKeyDown,
      on: this.v3 ? undefined : {
        "keydown": this.onButtonKeyDown,
        "focusin": this.onFocusHandler,
        "focusout": this.onButtonBlur
      },
      onFocusin: this.onFocusHandler,
      onFocusout: this.onButtonBlur
    }, [h("span", {
      onClick: this.onActiveColorClickHandler,
      on: this.v3 ? undefined : {
        "click": this.onActiveColorClickHandler
      },
      "class": 'k-input-inner'
    }, [h("span", {
      "class": kendo_vue_common_1.classNames('k-value-icon', 'k-color-preview', {
        'k-no-color': !this.computedValue,
        'k-icon-color-preview': this.icon || this.iconClassName
      })
    }, [(this.iconClassName || this.icon) && h("span", {
      "class": kendo_vue_common_1.classNames('k-color-preview-icon', this.iconClassName, (_a = {}, _a["k-icon k-i-" + this.icon] = this.icon && !this.iconClassName, _a))
    }), h("span", {
      "class": "k-color-preview-mask",
      style: {
        backgroundColor: this.computedValue
      }
    })])]), // @ts-ignore
    h(kendo_vue_buttons_1.Button, {
      type: "button",
      attrs: this.v3 ? undefined : {
        type: "button",
        tabindex: -1,
        rounded: null,
        icon: 'arrow-s'
      },
      tabindex: -1,
      ref: this.v3 ? function (el) {
        _this.buttonRef = el;
      } : 'button',
      onClick: this.onClickHandler,
      on: this.v3 ? undefined : {
        "click": this.onClickHandler
      },
      rounded: null,
      "class": "k-input-button",
      icon: 'arrow-s'
    }), // @ts-ignore function children
    h(Picker_1.Picker, {
      dir: dir,
      attrs: this.v3 ? undefined : {
        dir: dir,
        open: this.computedOpen,
        popupAnchor: this.focusableElementGuid
      },
      open: this.computedOpen,
      onOpen: this.onOpenHandler,
      on: this.v3 ? undefined : {
        "open": this.onOpenHandler
      },
      popupAnchor: this.focusableElementGuid
    }, this.v3 ? function () {
      return [(view === 'combo' || view === 'gradient') && renderGradiente.call(_this2), (view === 'combo' || view === 'palette') && renderPalette.call(_this2)];
    } : [(view === 'combo' || view === 'gradient') && renderGradiente.call(_this2), (view === 'combo' || view === 'palette') && renderPalette.call(_this2)])]);
  },
  methods: {
    focusElement: function focusElement() {
      if (this.$el) {
        this.$el.focus();
      }
    },
    setOpen: function setOpen(nextOpen, isBlur) {
      if (!nextOpen && !isBlur && this.$el) {
        this.$el.focus();
      }

      this.currentOpen = nextOpen;
      this.$emit(nextOpen ? 'open' : 'close');
    },
    onButtonKeyDown: function onButtonKeyDown(event) {
      var altKey = event.altKey,
          keyCode = event.keyCode;

      if (keyCode === kendo_vue_common_1.Keys.esc) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        return;
      }

      if (keyCode === kendo_vue_common_1.Keys.enter) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(!this.computedOpen);
        return;
      }

      if (altKey && keyCode === kendo_vue_common_1.Keys.down) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(true);
      }
    },
    onKeyDownHandler: function onKeyDownHandler(event) {
      var altKey = event.altKey,
          keyCode = event.keyCode;

      if (keyCode === kendo_vue_common_1.Keys.esc) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        return;
      }

      if (keyCode === kendo_vue_common_1.Keys.enter) {
        event.preventDefault();
        event.stopPropagation();
        this.focusElement();
        return;
      }

      if (altKey && keyCode === kendo_vue_common_1.Keys.up) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(false);
        this.focusElement();
      }
    },
    onOpenHandler: function onOpenHandler() {
      // Skip content autofocus when in controlled mode
      var palette = kendo_vue_common_1.getRef(this, 'palette');

      if (palette) {
        palette.focus();
      }
    },
    onClickHandler: function onClickHandler() {
      this.setOpen(!this.computedOpen, true);
    },
    onActiveColorClickHandler: function onActiveColorClickHandler(event) {
      this.$emit('activecolorclick', {
        event: event,
        value: this.computedValue
      });
    },
    isViewFocused: function isViewFocused() {
      var _a, _b;

      return !!((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('.k-colorpalette')) || !!((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest('.k-colorgradient'));
    },
    onButtonBlur: function onButtonBlur() {
      this.focused = this.isViewFocused();
    },
    onFocusHandler: function onFocusHandler(event) {
      if (this.blurTimeoutRef) {
        clearTimeout(this.blurTimeoutRef);
        this.blurTimeoutRef = undefined; // case where moving back to input from popup

        if (event.target === this.$el) {
          this.setOpen(false); // in this case we should focus input on keydown
        }
      } else {
        this.focused = true;
      }

      this.$emit('focus', {
        event: event
      });
    },
    onBlurTimeout: function onBlurTimeout() {
      var viewIsFocused = this.isViewFocused();

      if (!viewIsFocused) {
        this.setOpen(false, true);
      }

      this.focused = viewIsFocused;
      this.blurTimeoutRef = undefined;
    },
    onBlurHandler: function onBlurHandler(event) {
      clearTimeout(this.blurTimeoutRef);
      this.palette = kendo_vue_common_1.getRef(this, 'palette');
      this.gradient = kendo_vue_common_1.getRef(this, 'gradient');
      this.blurTimeoutRef = setTimeout(this.onBlurTimeout, 200);
      this.$emit('blur', {
        event: event
      });
    },
    onChangeHandler: function onChangeHandler(event, isPalette) {
      var currentValue = isPalette ? event.rgbaValue : event.value;

      if (!this.isValueControlled) {
        this.currentValue = currentValue;
      }

      if (isPalette) {
        this.setOpen(false);
      }

      this.$emit('change', {
        value: currentValue,
        event: event
      });
    },
    onGradientChangeHandler: function onGradientChangeHandler(event) {
      this.onChangeHandler(event, false);
    },
    onPaletteChangeHandler: function onPaletteChangeHandler(event) {
      this.onChangeHandler(event, true);
    }
  }
};
exports.ColorPickerVue2 = ColorPickerVue2;
/**
 * @hidden
 */

var ColorPicker = ColorPickerVue2;
exports.ColorPicker = ColorPicker;